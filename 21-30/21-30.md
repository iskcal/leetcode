21. 顺序遍历，小的接上，然后指针后移，大的不动，某个遍历完成，直接把另一个未遍历的部分直接接上

22. 采用动态规划，自己的想法：先生成$n-1$的所有匹配模式，然后在这些匹配模式中的所有位置之间插入$($，再在末尾插入$)$即为$n$的所有组合，但是注意的是这里的方法生成结果会有重复，需要判断重复性。性能不高

另外一种方法采用递归方式，主义的是所有排列中在没有达到$2n$的长度时，左括号数目一定大于等于右括号数目。并且所有组合一定以$($开始，以$)$结尾，因此可以递归确定每一位，比如说s为当前串，那么根据左右括号数目递归决定下一位字符。

23. 咋一看，只需要同时遍历k个链表，每次走一步即可，但是还有更节省时间的方式，即每次合并两个链表，可以再降低时间复杂度。

24. 每次寻找到待交换的两个前一个元素，修改指针走向使之逆序，注意结束条件是待逆序均有元素

25. 第24题的扩展，将逆序两个元素扩展到$k$个元素，大体思路是，每次确认第k个元素前一个元素作为其头节点，头节点的下一个元素作为尾节点，将之后的$k-1$个元素利用头插法插入到头节点之后的部分，形成逆序，注意要求只有头节点后续的个数超过$k$个才逆序，否则不动。思路比较简单，但是写起来很麻烦。

26. 双索引记录，返回不重复索引号加1即为长度

27. 和第26题差不多，只不过检测机制变成检测是否等于给定值

28. 字符串匹配问题，最简单的写法，注意匹配字符串为空的情形，另外，为了提高效率，似乎可以用KMS算法。

29. 实际上考察溢出和除法，由于python会自动转化数据类型，因此溢出不需要考虑，除法可以用动态规划来加快处理速度。

30. 这道题由于固定了长度（所有单词长度相同），所以变得不是很难。大体思想是间隔长度获取单词，判断是否在给出的词组中，如果有则继续，否则重置找到的词组。对于寻找注意的是词组中可能会有重复的，需要注意。