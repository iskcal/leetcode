5. 寻找字符串中最长的回文字符串

这种问题有一个比较简便的处理方式，该方式的时间复杂度$O(n^2)$，空间复杂度$O(1)$。其基本思想是遍历每一个元素，然后寻找以该元素为中心的最长回文字符串，便利完成后取最长字符串作为结果返回。注意一点是，回文有两种形式，一种是回文长度为偶数，对称中心在两个字母中间，另外一种是回文长度为奇数，对称中心在某个字母上。

另解：然而该问题还有其他方式的解，新解更加巧妙且其方式的时间复杂度降低为$O(n)$，空间复杂度提高至$O(n)$。https://articles.leetcode.com/longest-palindromic-substring-part-ii/，这是其算法具体思路（中文：https://www.felix021.com/blog/read.php?2040）。其具体想法是尝试在一次遍历中就计算出以每个字符为中心的最大回文字符串。改进点主要有两点，一是在字符串中每个字符前后插入无关字符，使得原本单独考虑的奇偶长度的回文字符串统一成一种处理方式。二是直接计算出每个字符的最大回文字符串长度，该方案使用了回文字符串对称的特性来提高算法的效率。

6. 首先明确下zip图形样子（https://leetcode.com/problems/zigzag-conversion/discuss/3435/If-you-are-confused-with-zigzag-patterncome-and-see!）。python的索引是从0开始的。

解法一：zip型拆开可以看成多个'|/'图形拼接起来，而一个'|/'共有$2(n-1)$个元素，这里n就是排成多少行。因此该解法就是将整个字符串拆分成$2(n-1)$个字符串，每个字符串每隔$2(n-1)$取下一个字符串。另外，在'|'型中，除开头尾两个，剩余中间部分需要和'/'型字符串交叉合并。最后再将整个字符串连接起来即为结果。注意到该方案需要对n为1时单独处理。

解法二：或者我们直接寻找最终字符串的下一位字符，首先明确的一点是，'|/'是以$2(n-1)$为循环的，即'|'上的索引为$i+2k(n-1)$，这里i表示第i行，k为自然数列。而'/'上可以看成是在当前'|'对应的索引j再加上$2(n-1)-2i$。也就是说'/'上的索引离下一个'|'上的对应索引小了$2i$个值。

7. 没啥好说的，一个从尾部获得数字，一个从头部开始乘10加。如果倒序数字绝对值超过2^31，则置0。

8. 按照流程来，主要也是乘10加，注意判断溢出条件，即当前数字未加上之前判断是否超过最大值的十分之一以及当前数是否超过其余数。符号判断主要在截取空格后的第一个字符判断。

9. 回文数，也没啥，有两种方案，一是把数字一位一位拆开分开比对，二是将数字逆序计算得到逆序数值，然后比较两个数字是否相等。两方案相比，前者需要更多的空间，后者如果在数字比较大时，逆序数值可能会溢出。

10. 基础的正则匹配，可以用自动机来解决。